import { SEMANTIC_MESSAGE_PATTERN } from '../constant';
export const parseLine = (message) => {
    const trim = message.trim();
    const matches = trim.match(SEMANTIC_MESSAGE_PATTERN);
    if (!matches) {
        return undefined;
    }
    return {
        type: matches[1],
        message: matches[3],
        normalized: `${matches[1]}: ${matches[3]}`,
        original: trim,
    };
};
export const normalize = (messages) => messages.map(item => item.toLowerCase());
export const isValidMessage = (type, message, types, excludeMessages) => types.includes(type) && !excludeMessages.includes(message.toLowerCase());
export const parseCommitMessage = (message, types, excludeMessages, breakingChangeNotes) => {
    const normalizedExcludeMessages = normalize(excludeMessages);
    const messages = message.trim().split(/\r?\n|\r/);
    const trim = messages[0].trim();
    const matches = trim.match(SEMANTIC_MESSAGE_PATTERN);
    if (!matches) {
        return undefined;
    }
    const notes = [];
    const children = [];
    messages
        .slice(1) // eslint-disable-line no-magic-numbers
        .map(message => parseLine(message))
        .filter(item => item)
        .map(item => item)
        .forEach(item => {
        if (breakingChangeNotes.length && breakingChangeNotes.includes(item.type)) {
            notes.push(item.original);
        }
        else if (isValidMessage(item.type, item.message, types, normalizedExcludeMessages)) {
            children.push(item);
        }
    });
    if (!isValidMessage(matches[1], matches[3], types, normalizedExcludeMessages) && (!children.length && !notes.length)) {
        return undefined;
    }
    return {
        type: matches[1],
        message: matches[3],
        normalized: `${matches[1]}: ${matches[3]}`,
        original: trim,
        children,
        notes,
    };
};
export const log = (log, logger) => {
    if (logger) {
        log(logger);
    }
};
