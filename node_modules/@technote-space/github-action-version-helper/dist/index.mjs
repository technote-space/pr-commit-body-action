import { Utils } from '@technote-space/github-action-helper';

// <type>(<scope>): <subject>
// @see https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716#semantic-commit-messages
const SEMANTIC_MESSAGE_PATTERN = /^(.+?)!?\s*(\(.+?\)\s*)?:\s*(.+?)\s*$/;
const MERGE_MESSAGE_PATTERN = /^Merge pull request #\d+ /;
const VERSION_BUMP = {
    'major': 0,
    'minor': 1,
    'patch': 2,
};

const parseLine = (message) => {
    const trim = message.trim();
    const matches = trim.match(SEMANTIC_MESSAGE_PATTERN);
    if (!matches) {
        return undefined;
    }
    return {
        type: matches[1],
        message: matches[3],
        normalized: `${matches[1]}: ${matches[3]}`,
        original: trim,
    };
};
const normalize = (messages) => messages.map(item => item.toLowerCase());
const isValidMessage = (type, message, types, excludeMessages) => types.includes(type) && !excludeMessages.includes(message.toLowerCase());
const parseCommitMessage = (message, types, excludeMessages, breakingChangeNotes) => {
    const normalizedExcludeMessages = normalize(excludeMessages);
    const messages = message.trim().split(/\r?\n|\r/);
    const trim = messages[0].trim();
    const matches = trim.match(SEMANTIC_MESSAGE_PATTERN);
    if (!matches) {
        return undefined;
    }
    const notes = [];
    const children = [];
    messages
        .slice(1) // eslint-disable-line no-magic-numbers
        .map(message => parseLine(message))
        .filter(item => item)
        .map(item => item)
        .forEach(item => {
        if (breakingChangeNotes.length && breakingChangeNotes.includes(item.type)) {
            notes.push(item.original);
        }
        else if (isValidMessage(item.type, item.message, types, normalizedExcludeMessages)) {
            children.push(item);
        }
    });
    if (!isValidMessage(matches[1], matches[3], types, normalizedExcludeMessages) && (!children.length && !notes.length)) {
        return undefined;
    }
    return {
        type: matches[1],
        message: matches[3],
        normalized: `${matches[1]}: ${matches[3]}`,
        original: trim,
        children,
        notes,
    };
};
const log = (log, logger) => {
    if (logger) {
        log(logger);
    }
};

var misc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    parseLine: parseLine,
    normalize: normalize,
    isValidMessage: isValidMessage,
    parseCommitMessage: parseCommitMessage,
    log: log
});

const listCommits = async (octokit, context) => (octokit.paginate)(octokit.rest.pulls.listCommits, {
    ...context.repo,
    'pull_number': context.payload.number,
});
const getCommits = async (types, excludeMessages, breakingChangeNotes, octokit, context) => (await listCommits(octokit, context))
    .filter(commit => !MERGE_MESSAGE_PATTERN.test(commit.commit.message))
    .map(commit => ({ commit, message: parseCommitMessage(commit.commit.message, types, excludeMessages, breakingChangeNotes) }))
    .filter(item => item.message)
    .map(item => ({
    sha: Utils.ensureNotNull(item.commit.sha),
    ...item.message,
}));

var commit = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getCommits: getCommits
});

const getCurrentVersion = async (helper) => helper.getLastTag();
const whatBump = (minorUpdateCommitTypes, commits) => {
    if (commits.filter(commit => commit.notes.length).length) {
        return 'major';
    }
    if (minorUpdateCommitTypes.length && commits.filter(commit => commit.type && minorUpdateCommitTypes.includes(commit.type)).length) {
        return 'minor';
    }
    return 'patch';
};
const getNextVersionLevel = (minorUpdateCommitTypes, commits) => VERSION_BUMP[whatBump(minorUpdateCommitTypes, commits)];
const getNextVersion = async (minorUpdateCommitTypes, excludeMessages, breakingChangeNotes, helper, octokit, context, logger) => {
    const commits = await getCommits(minorUpdateCommitTypes, excludeMessages, breakingChangeNotes, octokit, context);
    log(logger => logger.startProcess('Target commits:'), logger);
    log(() => console.log(commits
        .filter(item => item.notes.length || item.type)
        .map(item => ({
        type: item.type,
        message: item.message,
        notes: item.notes,
        sha: item.sha,
    }))), logger);
    log(logger => logger.endProcess(), logger);
    const current = await getCurrentVersion(helper);
    log(logger => logger.info('Current version: %s', current), logger);
    const next = Utils.generateNewVersion(current, getNextVersionLevel(minorUpdateCommitTypes, commits));
    log(logger => logger.info('Next version: %s', next), logger);
    return next;
};

var version = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getCurrentVersion: getCurrentVersion,
    whatBump: whatBump,
    getNextVersionLevel: getNextVersionLevel,
    getNextVersion: getNextVersion
});

export { commit as Commit, misc as Misc, version as Version };
