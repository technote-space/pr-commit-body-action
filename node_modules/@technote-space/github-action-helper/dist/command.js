"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const shell_escape_1 = __importDefault(require("shell-escape"));
/**
 * Command
 */
class Command {
    /**
     * @param {Logger} logger logger
     */
    constructor(logger) {
        this.logger = logger;
        /**
         * @param {string} command command
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressError suppress error?
         * @return {string} command
         */
        this.getCommand = (command, quiet, suppressError) => command + (quiet ? ' > /dev/null 2>&1' : '') + (suppressError ? ' || :' : '');
        /**
         * @param {string} command command
         * @param {string} altCommand alt command
         * @param {boolean} quiet quiet?
         * @param {ExecException} error error
         * @return {string} message
         */
        this.getRejectedErrorMessage = (command, altCommand, quiet, error) => {
            if ('string' === typeof altCommand) {
                if (!quiet) {
                    return `command [${altCommand}] exited with code ${error.code}. message: ${error.message}`;
                }
                else {
                    return `command [${altCommand}] exited with code ${error.code}.`;
                }
            }
            else if (!quiet) {
                return `command [${command}] exited with code ${error.code}. message: ${error.message}`;
            }
            return `command exited with code ${error.code}.`;
        };
        /**
         * @param {string} command command
         * @param {string|undefined} altCommand alt command
         * @param {boolean} quiet quiet?
         * @param {boolean} suppressOutput suppress output?
         * @param {boolean} stderrToStdout output to stdout instead of stderr
         * @param {function} resolve resolve
         * @param {function} reject reject
         * @return {void} void
         */
        this.execCallback = (command, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject) => (error, stdout, stderr) => {
            if (error) {
                reject(this.getRejectedErrorMessage(command, altCommand, quiet, error));
            }
            else {
                let trimmedStdout = stdout.trim();
                let trimmedStderr = stderr.trim();
                if (!quiet && !suppressOutput) {
                    if (trimmedStdout) {
                        this.logger.displayStdout(trimmedStdout);
                    }
                    if (trimmedStderr) {
                        if (stderrToStdout) {
                            this.logger.displayStdout(trimmedStderr);
                            trimmedStdout += `\n${trimmedStderr}`;
                            trimmedStderr = '';
                        }
                        else {
                            this.logger.displayStderr(trimmedStderr);
                        }
                    }
                }
                resolve({ stdout: trimmedStdout, stderr: trimmedStderr, command: 'string' === typeof altCommand ? altCommand : command });
            }
        };
        /**
         * @param {object} options options
         * @param {string} options.command command
         * @param {string[]|undefined} options.args command
         * @param {string|undefined} options.cwd cwd
         * @param {boolean|undefined} options.quiet quiet?
         * @param {string|undefined} options.altCommand alt command
         * @param {boolean|undefined} options.suppressError suppress error?
         * @param {boolean|undefined} options.suppressOutput suppress output?
         * @param {boolean|undefined} options.stderrToStdout output to stdout instead of stderr
         * @return {Promise<object>} output
         */
        this.execAsync = (options) => new Promise((resolve, reject) => {
            const { command, args, cwd, altCommand, quiet = false, suppressError = false, suppressOutput = false, stderrToStdout = false } = options;
            const commandArgs = undefined === args ? '' : shell_escape_1.default(args.map(item => item.trim()).filter(item => item.length));
            const commandWithArgs = command + (commandArgs.length ? ' ' + commandArgs : '');
            if (undefined !== altCommand) {
                if (altCommand) {
                    this.logger.displayCommand(altCommand);
                }
            }
            else if (!quiet) {
                this.logger.displayCommand(commandWithArgs);
            }
            if (typeof cwd === 'undefined') {
                child_process_1.exec(this.getCommand(commandWithArgs, quiet, suppressError), this.execCallback(commandWithArgs, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
            }
            else {
                child_process_1.exec(this.getCommand(commandWithArgs, quiet, suppressError), { cwd }, this.execCallback(commandWithArgs, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
            }
        });
    }
}
exports.default = Command;
